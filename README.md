# minscript - a simple Java/C++ like script interpreterMinscript  is an object oriented scripting language. The scripting language is a small subset of the C++ language. It has even more in common with Java than with C++. The aim of  the script language is not to execute all possible C++ programs, instead every valid minscript program should compile with a C++ compiler. Have a look at the sample script to get an impression of the syntax of the scripting language.The main features of the minscript language are:- preprocessor (#define's and #ifdef's are possible!)- buildin types: bool, char, int, double, string- typedef- expressions- statements: if/else, for, while, do/while, switch- functions- function overloading- classes and structs- virtual methods- multiple inheritance- scope mechanism in blocks- template-classes- references and pointers (in a very simple way, no pointer arithmetic possible)- C/C++ API- multiplattform support, runs on: Windows, Linux, OS/2- a lot of buildin functions- some language extensionsNot supported features of the C++ language are:- no extern declarations of methods, all methods have to be declared inline !- no operator overloading- no template functions- no templates in typedefs, use #define's- no explicit casts (the buildin types are casted automatically)- no iostream's- no goto's- no default arguments in functions or methods (example: int f( int i = 0 ) {})- no multidimensional arrays (example: int aArray[4][4];)- no pointer arithmetic (example: int * p; ... p = p+1;)Features of the minscript program package are:- preprocessor- external functions in loadable modules- stubcode-generator for automatic creation of stubcode needed for the registration of  external functions in the interperter- wrappercode-generator for automatic creation of wrapper-classes- test scripts to validate the minscript-interpreter against a c++ compiler (see: specs/auto_test.ic)Known bugs of minscript are:- #if defined( 1 ) is false- const modifier of methods is not verified- every virtual method has to be declared with the virtual keyword, even if the method is declared as virtual in the baseclass - for( int i=0; i<10; i++ ) {} doesn't work, you can not declare variables in the for-statement- long, short, unsigned doesn't work, use long int, short int, unsigned int- case-labels don't have to be constant!- arrays can not created dynamically (example: int * pArray = new int [8];)- aObj.f() works even if the class of aObj has no method with name f() but a function with name f() exists- there are some problems with virtual destructors or references for objects with virtual methods, see test_classes.ic- access to private member variables of classes is possible- not all keywords have the same meaning as in C++: extern, static, const- you could write valid minscript programs which will not compile with a C++ compiler- not all templates features are supported- there are a lot of unknown bugs!Open issues:- Add automated unit testsPlatforms  ---------Minscript is written in (plain) C++ and therefore supports (in principle) all platforms which have a C++ compiler.Minscript was successfully compiled on Windows, Mac OS X, Android, Linux (including the Raspberry Pi) and OS/2. * Windows [![Build status](https://ci.appveyor.com/api/projects/status/9kews6098r0qhfuh?svg=true)](https://ci.appveyor.com/project/mneuroth/minscript)* MacOS, Linux and Android [![Build Status](https://travis-ci.org/mneuroth/minscript.svg?branch=master)](https://travis-ci.org/mneuroth/minscript)Sample script-------------Sample1.ic:    /*         A simple sample script with some features    */        #define MAX	512        const string c_sString = "C++ is nice.";        // a simple class to test the scope mechanismus     class MyTestClass    {    public:        // allways inlining !        MyTestClass( int i )        {            __println( "MyTestClass::MyTestClass(int) i="+i );            m_i = i;        }        ~MyTestClass()        {            __println( "MyTestClass::~MyTestClass(int) i="+m_i );        }            int f()        {            return m_i*m_i;        }    private:        int    m_i;    };        void TestFunction( string s, double d )    {        double dResult = d * d - 4.5;        string sTemp;            /* create a result string */        sTemp = s + " Result="+dResult;            // now print the string        __println( sTemp );    }        int main()    {        TestFunction( "Hello minscript world ! This is a function.", 9.123 );            __println( "test scope..." );        {            MyTestClass aObj( 7 );                __println( "aObj.f() = " + aObj.f() );        }        __println( "test scope done." );            return 0;    }        #ifdef __MINSCRIPT__    main();    #endifThe output of this script is (run: minscript Sample1.ic):    Hello minscript world ! This is a function. Result=78.729129    test scope...    MyTestClass::MyTestClass(int) i=7    aObj.f() = 49    MyTestClass::~MyTestClass(int) i=7    test scope done.    Buildin functions:------------------    int __print( string s )                         prints a string to the standard output stream    int __println( string s )                       prints a string to the standard output stream and appends a new line    int __errorln( string s )                       prints a string to the error stream and appends a new line    void __sleep( int iDelay )                      suspends the program execution for iDelay ms    int __loaddll( string s )                       load the module with a given name, returns the handle for the module    int __unloaddll( int hDll )                     frees the module    long clockms()                                  return the clock value in ms        int sizeof( expression )                        returns the size of the expression type         int fopen( string sFileName, string sMode )     opens a file in sMode (usual file-modes from <stdio.h>)    int fclose( int hFile )                         closes a file    int feof( int hFile )                           checks a file for end-of-file status    int ferror( int hFile )                         checks a file for error status    int fputs( string sText, int hFile )            writes a string into a file    int fgets( string & sText, int hFile )          reads a string from a file            int current_time_hour()                         return the hour value of the current time    int current_time_minute()                       return the minute value of the current time    int current_time_second()                       return the second value of the current time    int current_date_year()                         return the year of the current date    int current_date_month()                        return the month of the current date    int current_date_day()                          return the day of the current date            string getenv( string sName )                   reads an environment variable    int putenv( string sNameValue )                 writes an environment variable    void exit( int iValue )                         exits the program imediately with the exit-code iValue    int system( string sCmd )                       system call, runs (synchroniously) the command in the string sCmd    bool splitpath( string sFullPath, string & sDrive, string & sPath, string & sName, string & sExt )                                                    splits a given path in substrings for drive, path, name and extension        int string_read()                               reads a string from the standard input and returns the string    int string_npos()                               returns a integer constant to show that the find-function was not successfull    int string_length( string s )                   returns the length of the string    char string_at( string s, int iPos )            returns the character in the string at the given position    string string_setchar( string s, int iPos, char ch )            returns a string with the changed character at the given position     int string_find( string s, string sSearch )     returns the position of the sSerach-string in the string s, returns string_npos() if the search string was not found    string string_substr( string s, int iStartPos, int iLength )    returns a substring of the given string    string string_insert( string s, int iPos, string sInsert )      returns a string in which the sInsert string is inserted in the string s    string string_erase( string s, int iPos, int iLength )          returns a string in which the given range is erased    string string_replace( string s, int iPos, int iLength, string sReplace )    returns a string in which a part of the string is replaced by another string        double fabs( double d )                         returns absolute value of d    double sin( double d )                          returns the sinus of d    double asin( double d )                         returns the arcus-sinus of d    double sinh( double d )                         returns the sinus hyperbolicus of d    double cos( double d )                          returns the cosinus of d     double acos( double d )                         returns the arcus-cosinus of d     double cosh( double d )                         returns the cosinus hyperbolicus of d     double tan( double d )                          returns the tangens of d    double atan( double d )                         returns the arcus-tangens of d    double atan2( double d1, double d2 )            returns the arcus-tangens of d     double tanh( double d )                         returns the tanges hyperbolicus of d    double sqrt( double d )                         returns the squareroot of d    double exp( double d )                          returns the e the power of d    double log( double d )                          returns the logarithm of d    double log10( double d )                        returns the logarithm for base 10 of d    double pow( double d1, double d2 )              returns the power of d1 by d2Language extensions-------------------    __exists variablename        verifys if a variable with the given name exists    __dbghalt expression         sets an user brakepoint, the execution of the script will be stoped when this statement will be reached.                                 Dumps all functions and methods if expression has the value "fcn".    typeof variablename          prints the type of the variablePredefined symbols of the preprocessor--------------------------------------    __MINSCRIPT__       is defined if the script is executed by the minscript application    __STDC__            is allways set    __cplusplus         is allways set    _WIN32              is defined if the script is executed on the windows plattform    __MINGW32__         is defined if the script is executed on the Windows/Mingw plattform    __OS2__             is defined if the script is executed on the OS/2 plattform    __ZAURUS__          is defined if the script is executed on the ZAURUS plattform    __ANDROID__         is defined if the script is executed on the Android plattform    __APPLE__           is defined if the script is executed on an Apple/MacOS plattform    __linux__           is defined if the script is executed on the linux plattform    __UNKNOWN__         is defined if the script is executed on an unknown plattform    _NDEBUG             is defined if the script is executed without the --debug option    _DEBUG              is defined if the script is executed with the --debug optionCommandline options-------------------Start minscript with the option -? for a complete list of available options.Module interface----------------To generate a module see the demo module example.The folowing steps are necessary- write the C/C++ implementation of the module (example: module_test.h, module_test.cpp)- generate the stub files for your implementation files using the minscript-program (example: minscript  --mmakestubs >module_test.h.cpp)- optional: if your implementation module uses classes, you have to generate wrapper-classes for the minscript  interpreter: (example: minscript --makewrappers module_test.h >module_test.ic). Use this wrapper files with an #include statement.- generate the makefile to create the shared library (linux) or dll (windows). (example: minscript --makemakefile module_test.h)- generate the shared library (module.so) or dll (module.dll) with make or nmake.- test the generated module (module.*) by loading the module with __loaddll("module.so") or __loaddll("module.dll")All these steps are done in the script buildmodule.ic (minscript buildmodule.ic -a module_test.h).License-------Minscript is released under the GPL licenseWarning: The minscript package comes without any warranty. Use it at your own risk.Homepage: https://github.com/mneuroth/minscript